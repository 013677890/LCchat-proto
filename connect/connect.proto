syntax = "proto3";

package connect;

option go_package = "github.com/013677890/LCchat-Backend/apps/connect/pb";

import "validate/validate.proto";

// ==================== 消息封装（Websocket 下行协议） ====================

// MessageEnvelope 为 WebSocket 下行消息统一封装格式。
// 建议业务层将真实 payload 放在 data 字段，type 用于客户端分发。
message MessageEnvelope {
	// type: 消息类型（如 MSG_PUSH / MSG_RECALL / KICKOUT 等）。
	string type = 1 [(validate.rules).string = {min_len: 1, max_len: 64}];
	// data: 业务负载（如 MsgItem / RecallNotice 序列化后的 bytes）。
	bytes data = 2;
	// seq: 消息序列号，客户端用来去重/排序。
	int64 seq = 3;
	// server_ts: 服务端事件时间戳。
	int64 server_ts = 4;
	// trace_id: 链路追踪 ID。
	string trace_id = 5;
	// ack_required: 是否需要客户端回执。
	bool ack_required = 6;
}

// ==================== 内部流转事件（Pub/Sub 或 Kafka） ====================
// 注意：Connect-Service 是无头消费节点，不再提供任何 gRPC 接口。
// 业务方的指令（如单播、广播、踢线）需包装为下方 Event 投入 Redis Pub/Sub 或 Kafka Topic，
// 所有 Connect 节点收到广播后自主匹配内存中的 WebSocket 连接并执行动作。

// 1. KickEvent 踢线事件
// 场景：业务方（如 user-service）需要强制断开某用户的某个设备连接。
// 介质：Redis Pub/Sub -> "connect:events:kick"
message KickEvent {
	// user_uuid: 目标用户 UUID。
	string user_uuid = 1 [(validate.rules).string.min_len = 1];
	// device_id: 目标设备 ID（如需踢出给定用户的所有设备，可约定传入特殊值如 "ALL" 或单独加字段）。
	string device_id = 2 [(validate.rules).string.min_len = 1];
	// reason: 踢线原因，收到此事件的 Connect 节点打包为 MessageEnvelope{type="KICKOUT"} 下发给客户端。
	string reason = 3;
}

// 2. BroadcastEvent 全服/批量广播事件
// 场景：向全服或特定大批量用户做系统通知（如系统维护公告）。
// 注意：聊天消息下发走 msg.push (Kafka)，系统级别的广播走此事件。
// 介质：Redis Pub/Sub -> "connect:events:broadcast"
message BroadcastEvent {
	// user_uuids: 目标用户列表。若为空，则表示向当前节点维护的**所有**连接广播（全服广播）。
	repeated string user_uuids = 1 [(validate.rules).repeated.max_items = 5000];
	// message: 待投递消息体。所有 Connect 节点会将此 Envelope 投递给命中的 user_uuid。
	MessageEnvelope message = 2 [(validate.rules).message.required = true];
}
