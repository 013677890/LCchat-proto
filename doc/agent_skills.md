## Agent Skills Guide

This document captures the development conventions and skills needed to work
in this project. It is intended for AI agents and new contributors.

### 1. Tech Stack Overview
- Go 1.25, layered architecture (gateway + user service)
- gRPC for service-to-service calls
- Gin for HTTP gateway
- GORM for database access
- Redis for cache/token/verification code
- Protobuf + validate rules for request schema

### 2. Code Structure & Modules
- `apps/gateway/`: HTTP gateway, DTOs, routing, gRPC client calls
- `apps/user/`: user service, business logic, repositories, protobufs
- `pkg/`: shared utilities (redis, logger, util)
- `consts/`: error codes and message map
- `doc/`: product and API documentation

#### 2.1 Where to Read First
- `doc/API接口规范.md`: common API conventions
- `doc/user_doc/*`: per-module API docs (auth, user, friends, blacklist)
- `doc/07-错误码.md`: full error code definitions

### 3. Conventions & Patterns

#### 3.1 Error Handling
- Business errors are encoded as `grpc/status` with numeric error codes in
  the message, then extracted in gateway via `utils.ExtractErrorCode`.
- Use `consts.IsNonServerError(code)` to decide if it is a user-facing error.
- Log internal errors with context and return `CodeInternalError`.

#### 3.2 DTO ↔ Protobuf Conversion
- Gateway request DTOs live in `apps/gateway/internal/dto`.
- Always convert DTOs to Protobuf using `ConvertToProto...` functions.
- Always convert Protobuf responses to DTO using `Convert...FromProto`.

#### 3.3 Context & Device Info
- Gateway attaches device ID via `X-Device-ID` or context key `device_id`.
- User service reads device info from context and `req.DeviceInfo`.
- Defensive coding: guard `req.DeviceInfo == nil` to avoid nil pointer.

#### 3.4 Logging
- Use `logger.Info/Warn/Error` and include key fields (email, device, ip).
- Avoid logging raw password or verify codes; mask account where possible.

#### 3.5 Redis Usage
- Verification codes stored in Redis with TTL (e.g., 2 minutes).
- Tokens stored in Redis with Access/Refresh expiry.
- Rate limiting uses counters + TTL; avoid extending TTL on every increment.
- When verification succeeds, delete the code to prevent reuse.

#### 3.6 Routing Style
- Public routes grouped under `/api/v1/public/user/...`.
- Add new endpoints in:
  - `apps/gateway/internal/router/v1/auth_handle.go`
  - `apps/gateway/internal/router/router.go`
  - `apps/gateway/internal/service/*`
  - `apps/user/internal/service/*`

#### 3.7 Response Envelope
- Gateway responses always use `pkg/result/response.go`:
  - JSON: `code`, `message`, `data`, `trace_id`
  - HTTP 200 for business errors; HTTP 500 for server errors (3xxxx).

#### 3.8 Error Code Ranges
- 1xxxx: client errors (param/body/too many requests)
- 2xxxx: auth errors (token/permission)
- 11xxx: user module errors (email/password/verify code)
- 12xxx+: other modules (friend, message, group, device, blacklist)
- 3xxxx: server errors (internal, timeout, unavailable)

#### 3.9 Config & Runtime
- Configs live in `config/`:
  - `mysql.go`, `redis.go`, `logger.go`
- Local dev often uses `docker-compose.yml`.
- Database init SQL: `config/mysql/init.sql`.
- Avoid committing changes to `data/` (runtime databases).

#### 3.10 Database & Models
- Models in `model/` map to DB tables.
- Repository layer in `apps/user/internal/repository` wraps DB/Redis access.
- Use `WrapDBError` and `WrapRedisError` for consistent error mapping.

#### 3.11 Protobuf & Validation
- Protos in `apps/user/pb/*.proto`.
- Validation rules via `validate/validate.proto` and generated `*.pb.validate.go`.
- After proto changes, regenerate stubs using existing tooling or scripts.

#### 3.12 Redis Key Design (Common Patterns)
- Verification codes: `user:verify_code:{email}`
- Rate limit counters:
  - `user:verify_code:1m:{email}`
  - `user:verify_code:24h:{email}`
  - `user:verify_code:1h:{ip}`
- Tokens: stored via `deviceRepo` helpers.

#### 3.13 Observability
- `trace_id` generated by middleware, returned in response.
- `business_code` is stored in context for metrics middleware.

### 4. Required Skills for Future Agents

#### Go Fundamentals
- Interfaces and dependency injection
- Context propagation (`context.Context`)
- Error wrapping and comparison (`errors.Is`)

#### gRPC
- Protobuf schema updates in `apps/user/pb/*.proto`
- Regeneration of stubs/validation if needed (check existing tooling)
- Mapping gRPC errors to gateway error codes

#### Gin HTTP Handling
- Binding and validation (`ShouldBindJSON`)
- Consistent error responses via `result.Fail` / `result.Success`

#### Redis Patterns
- TTL and key design
- Atomic operations (Lua where needed)
- Rate limit counters (per email / per IP)

#### GORM & SQL
- Basic CRUD, query building, transactions
- Error mapping for `record not found` and unique conflicts

#### Documentation Hygiene
- Update `doc/user_doc` when endpoints or paths change.
- Keep paths consistent with gateway routes.

### 5. Example: Adding a New Auth Endpoint
1. Define request/response in `apps/user/pb/auth_service.proto`.
2. Implement in `apps/user/internal/service/auth_service.go`.
3. Add repository methods if needed in `apps/user/internal/repository`.
4. Expose gRPC in gateway service layer.
5. Add DTOs and converters in `apps/gateway/internal/dto`.
6. Add route and handler in `apps/gateway/internal/router`.
7. Update documentation in `doc/user_doc`.

### 6. Security Checklist
- Never log sensitive fields (passwords, verify codes).
- Delete verification codes after successful validation.
- Validate email/phone formats before DB or Redis operations.
- Rate limit verification code sending and checking.

### 7. Minimal Change Workflow (Recommended)
1. Read existing handler/service for the same module.
2. Update proto + regenerate code if schema changes.
3. Implement user service business logic and repo changes.
4. Expose gateway handler/service + DTO conversions.
5. Update docs and ensure route paths match.
6. Run lints on edited files.
