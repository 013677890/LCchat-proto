syntax = "proto3";

package connect;

option go_package = "github.com/013677890/LCchat-Backend/apps/connect/pb";

import "validate/validate.proto";

// ConnectService 定义 connect 对外暴露的 gRPC 能力。
//
// 架构定位：Connect 是纯粹的"最后一公里"管道。
// 它不直接对接 Kafka，也不做任何业务判断（读扩散/写扩散/路由查询等）。
// 上游的 Push-Job（Kafka 消费者）在查完 Redis 路由表、拆分完群成员之后，
// 会通过 gRPC 精确地告诉 Connect："把这条消息发给你节点上的张三"。
//
// 调用方：
// 1. push-job（Kafka 消费者） — 消息下发、撤回通知、已读同步
// 2. user-service            — 踢线（封号/异地登录）
// 3. 运维/管理后台           — 全服广播
service ConnectService {
	// PushToDevice 向指定用户的指定设备投递消息。
	// 典型场景：单设备回执、仅当前设备可见的安全提示。
	rpc PushToDevice(PushToDeviceRequest) returns (PushToDeviceResponse);

	// PushToUser 向用户在本节点上的所有在线设备广播。
	// 典型场景：push-job 查到用户在此节点，直接推全设备。
	rpc PushToUser(PushToUserRequest) returns (PushToUserResponse);

	// BroadcastToUsers 批量向多个用户广播相同的消息。
	// 典型场景：全服维护公告（管理后台遍历所有 Connect 节点调用）。
	// 限制：单次最多 1000 个用户，超出应分批调用。
	rpc BroadcastToUsers(BroadcastToUsersRequest) returns (BroadcastToUsersResponse);

	// KickConnection 主动断开指定设备连接。
	// 典型场景：user-service 封禁账号 / 异地登录时精确踢线。
	// 注意：调用方（user-service）需先查 Redis 路由表获取目标所在 Connect 节点地址，
	// 才能将 gRPC 请求打到正确的节点。
	rpc KickConnection(KickConnectionRequest) returns (KickConnectionResponse);
}

// ==================== 消息封装（WebSocket 下行协议） ====================

// MessageEnvelope 为 WebSocket 下行消息统一封装格式。
// 业务方将真实 payload 放在 data 字段，type 用于客户端路由分发。
message MessageEnvelope {
	// type: 消息类型路由键（如 MSG_PUSH / MSG_RECALL / MSG_MARK_READ / KICKOUT）。
	string type = 1 [(validate.rules).string = {min_len: 1, max_len: 64}];
	// data: 业务负载（如 MsgItem / RecallNotice 序列化后的 bytes）。
	bytes data = 2;
	// seq: 消息序列号，客户端用来去重/排序。
	int64 seq = 3;
	// server_ts: 服务端事件时间戳（unix 毫秒）。
	int64 server_ts = 4;
	// trace_id: 链路追踪 ID，便于跨服务排障。
	string trace_id = 5;
	// ack_required: 是否需要客户端回执。
	bool ack_required = 6;
}

// ==================== 单推 / 广推 ====================

message PushToDeviceRequest {
	// user_uuid: 目标用户 UUID。
	string user_uuid = 1 [(validate.rules).string.min_len = 1];
	// device_id: 目标设备 ID。
	string device_id = 2 [(validate.rules).string.min_len = 1];
	// message: 待投递消息体。
	MessageEnvelope message = 3 [(validate.rules).message.required = true];
}

message PushToDeviceResponse {
	// delivered: true 表示目标连接存在且已成功入队。
	bool delivered = 1;
}

message PushToUserRequest {
	// user_uuid: 目标用户 UUID。
	string user_uuid = 1 [(validate.rules).string.min_len = 1];
	// message: 待广播消息体（推送到该用户在本节点的所有在线设备）。
	MessageEnvelope message = 2 [(validate.rules).message.required = true];
}

message PushToUserResponse {
	// delivered_count: 成功入队的设备数量。
	int32 delivered_count = 1;
}

// ==================== 批量推送 ====================

message BroadcastToUsersRequest {
	// user_uuids: 目标用户 UUID 列表，单次上限 1000。
	repeated string user_uuids = 1 [(validate.rules).repeated = {min_items: 1, max_items: 1000}];
	// message: 待广播消息体（所有用户收到的是同一条消息）。
	MessageEnvelope message = 2 [(validate.rules).message.required = true];
}

message BroadcastToUsersResponse {
	// success_count: 至少有一个设备成功入队的用户数。
	int32 success_count = 1;
	// total_delivered: 所有用户的所有设备成功入队的总数。
	int32 total_delivered = 2;
}

// ==================== 踢线 ====================

message KickConnectionRequest {
	// user_uuid: 目标用户 UUID。
	string user_uuid = 1 [(validate.rules).string.min_len = 1];
	// device_id: 目标设备 ID。
	string device_id = 2 [(validate.rules).string.min_len = 1];
	// reason: 踢线原因，可用于客户端提示（如"账号在其他设备登录"）。
	string reason = 3;
}

message KickConnectionResponse {
	// success: true 表示目标连接存在且已断开；false 表示目标原本不在线。
	bool success = 1;
}
